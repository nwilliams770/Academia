Given by Victor Savkin
- Types of state:
    - Server state: Not technically a part of Angular application but we need to deal with it so keep it in mind
    - Persistent State: Subset sort of server state on client end, sort of a cache of the server state. Note that in most cases though, we want to do domestic updates. E.g. update something in persistent state then later update server state, and hopefully they reconcile!
    - Client state: Not stored of server. good practice to reflect both persistent and client state in the url
    - URL or router state: With that recc
    - Transient client side: state we store for the client but NOT in the URL. EX: youtube videos that pick up from where you last watched them.
    - Local UI state: local components can have local UI state and usually derived from other types of state, like a button color
- State Synchronization: Why Though?
    - We need to sync because we have the same info stored multiple places. Server state and persistent state as well as persistent state, client state, and url/router state. 
    - Problem: Syncing persistent state and server state:
        - Let's say we want to submit a rating. Currently our backend has no code for an (inevitable) request failure. Our persistent state updated domestically on client side yet it is really not stored in our backend
        - We can do something like, when an error occurs, we throw and error to our frontend and reset the rating to NULL. BUT, consider this monkey wrench:
            - User sends two requests in a short amount of time, maybe they misclicked and entered the wrong rating or somthing. One request fails and one is successful--there is NO guarantee which response from the backend will come first so if our error message comes last, we reset rating to NULL on client side even though the successful request updated the server state. We are now out of sync!
    - Problem: Syncing URL and Client state
        - Same problem as previously, multiple requests within a short time of eachother can disrupt the synchronization of these two states because there's no guarantee in what order responses come back
- Even with these errors, these faulty componenents will more than likely pass both unit and end-to-end tests. Why? Because most tests, unless explicity designed to, don't test race conditions in which these errors occur
- To sum it up: 
    - State management and side effects aren't separeted
    - No clear sync strategy of the persistent state and server
    - No clear sync strategy of client state and url
    - Our model is mutable
- Some solutions
    - Separate services/computation from state management:
        - Using a separate state management library such as redux, we can create a model where:
            - Components dispatch actions to Store that can update state based on those actions and effect classes and can execute actions to sserver based on actions coming from components
            - Use immutable data for persistent and client state, we create a new copy of our data in the reducer and return an entirely new state. Why? Because it is shared across multiple components and different parts of app
            - Effects class using RxJS Observable to get rate actions and with each action, makes request. If request fails, we dispatch a new action
            - note `concatMap`, will wait for response before sending new request. Because we have a single Observable for all actions, we can use concatMap to order/linearize the requests
            - Optimistic updates should always have special, separate actions to deal with errors
            - State management done by reducers and side-effects handled by Effects classes, clear UNDO strategy, no more race conditions with `concatMap`
            - NgRX/Redux means of successful state management, not a guarantee!
    - Synchronizing URL and client state
        - Always treat Router (url) as the source of truth! Why? Because the user can always update the URL directly. App has to support both case of using a back button AND user manually changing url
        - The data flow we want: Component calls Navigate => Router updates Location => Store/Effects get notified => Store updates its state => Componenet gets new state
        - We are going to emit an event called "ROUTER NAVIGATION", our Effects class will listen to that event and fetch the data, but we are using `switchMap` not `concatMap`, why?
            - `switchMap` only handles the latest value, if a new action appears, we no longer care about the previous one.